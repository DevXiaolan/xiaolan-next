{
  "id": 329,
  "title": "左手抽象语法树，右手自动化编程",
  "keywords": [
    "AST",
    "自动化"
  ],
  "createdAt": 1610440578,
  "updatedAt": 1610440578,
  "desc": "再不努力你就要被机器取代！如何让技术工作者专注于无法被机器取代的部分，而不是拼体力去和自动化机器抢生意。",
  "content": "> 随着软件开发技术的不断进步，处理偶发复杂度的行为都有可能被自动化、被机器取代；只有处理本质复杂度的建模行为，无法被机器取代。 —— 熊大\n\n引用上面一段话，是因为它很好地点出了这几年我一直专注的方向，如何让技术工作者专注于无法被机器取代的部分，而不是拼体力去和自动化机器抢生意。\n\n###再不努力你就要被机器取代！\n\n\n\n为什么会有这种焦虑？并不是源于现在网络上一直吹嘘的人工智能，而是来自自我反省。\n\n![](https://lanhaooss.oss-cn-shenzhen.aliyuncs.com/images/329/1.png)\n\n最近在研究一些代码质量分析系统的时候，其中有一项就是代码的重复率。意思就是你一直以来提交的代码里，在做多少重复的劳动？\n\n且不论这个系统的科学性和准确性，但它的确给了我一个声音，我从直觉是感到自己平时也写很多重复代码。\n\n###🔥好了感慨完进入正题，首先，怎么找到重复劳动？\n\n我们看一段代码\n\n\n\timport * as mongoose from 'mongoose';\n\t\n\tenum Lang { js, java, c }\n\t\n\texport interface IUserModel extends mongoose.Document {\n\t  name: string;\n\t  age: number;\n\t  language: Lang;\n\t}\n\t\n\tconst schema = new mongoose.Schema(\n\t  {\n\t    name: {\n\t      type: String,\n\t      require: true, \n\t    },\n\t    age: {\n\t      type: Number,\n\t      require: true, \n\t    },\n\t    language: {\n\t      type: Lang,\n\t      require: true, \n\t      enum: [ Lang.js, Lang.java, Lang.c ],\n\t    },\n\t  },\n\t  {\n\t    usePushEach: true,\n\t    timestamps: {\n\t      createdAt: 'createdAt',\n\t      updatedAt: 'updatedAt',\n\t    },\n\t  },\n\t);\n\t\n\texport default mongoose.model('user', schema);\n\n\n如何识别上面的重复代码？表面看来，真正在运行中有用的部分，是 `new mongoose/Schema(...)` 这部分，但我们判断的依据并不在此。\n\n> 代码编写实际上是体现了我们的主观意图。\n\n抛开其他旁杂的知识体系，在这段代码里，我们的主观意图是\n\n###**⭐️定义一个用户类型的模型**\n\n再简化一下，就是\n\n###**⭐️定义用户类型**\n\n所以我思考上面这几十行代码，哪些是代表我自己的主观意图，哪些是机器没法代替的部分呢？\n\n其实仅仅是用户接口类型的定义\n\n\n\t\n\tenum Lang { js, java, c }\n\t\n\texport interface IUserModel extends mongoose.Document {\n\t  name: string;\n\t  age: number;\n\t  language: Lang;\n\t}\n\n\n至于如何使用 `mongoose`去定义一个 `Schema`，再导出一个`Model`实例，这些每次都要我翻看在线文档的操作，我恨不得交给计算机去做。\n\n![](https://lanhaooss.oss-cn-shenzhen.aliyuncs.com/images/329/2.jpg)\n\n**🔥而接下来我就是要让计算机来完成这个任务。**\n\n> 🤡 这个真的可行吗？\n> \n> 🤖 理论上是可以的，只要你确定某些操作，完全没有注入自己的脑力创作元素，那它一定可以被计算机替代。\n\n如果这真的可以做到，那么理想情况下，我们需要自己编写的代码，只剩下这些。\n\n\n\timport * as mongoose from 'mongoose';\n\t\n\tenum Lang { js, java, c }\n\t\n\texport interface IUserModel extends mongoose.Document {\n\t  name: string;\n\t  age: number;\n\t  language: Lang;\n\t}\n\n\n很好，只定义了一个用户的接口类型，符合我们的主观意图。\n\n然后使用程序**分析这段代码**\n\n\n\t//  因为讲解需要，对原始 AST 输出做了简化，突出重点\n\t\n\t[\n\t  {\n\t    type: 'ImportDeclaration',\n\t    source: {\n\t      value: 'mongoose'\n\t    },\n\t  },\n\t  {\n\t    type: 'TSEnumDeclaration',\n\t    id: { type: 'Identifier', name: 'Lang' },\n\t    members: [ 'js', 'java', 'c' ]\n\t  },\n\t  {\n\t    type: 'ExportNamedDeclaration',\n\t    declaration: {\n\t      type: 'TSInterfaceDeclaration',\n\t      body: [{...},{...},{...}],\n\t      id: { name: 'IUserModel' },\n\t      extends: ['Document']\n\t    },\n\t  }\n\t]\n\n\n可见，我们只写了三行代码。\n\n1. 引入一个依赖 mongoose\n2. 定义了 Lang 枚举类型\n3. 导出了 用户接口，继承自 Document\n\n从以上信心里，我需要机器人捕捉到的关键是第三行代码🔍。\n\n我们可以根据`AST`结构的特征，让机器人只处理 `TSInterfaceDeclaration `并且 `extends` 自 `Document`的，这个逻辑简单自然是不需要帖代码的，大家都能理解。\n\n###🔥然后我们需要让机器人明白我们的  `TSInterfaceDeclaration ` 语句，定义了一个怎样的（包含哪些字段类型）的接口类型。\n\n我们在展开一下上面的 `body: [{...},{...},{...}],`\n\n\n\t// 因为讲解需要，对原始 AST 输出做了简化，突出重点\n\t\n\t[\n\t  {\n\t    key: { name: 'name' },\n\t    typeAnnotation: {\n\t      type: 'TSStringKeyword',\n\t    }\n\t  },\n\t  {\n\t    key: { name: 'age' },\n\t    typeAnnotation: {\n\t      type: 'TSNumberKeyword',\n\t    }\n\t  },\n\t  {\n\t    key: { name: 'language' },\n\t    typeAnnotation: {\n\t      type: 'TSTypeReference',\n\t      typeName: { name: 'Lang' }\n\t    }\n\t  }\n\t]\n\n\n这部分如果比较晦涩，可以对照着 `IUserModel`的定义，就很好读懂了。\n\n主要就是表达了`IUserModel`里三个字段的类型定义，已经能清楚看出`name`是一个字符串类型，`age`是一个数字类型，而`language`则是一个`Lang`的引用类型。\n\n###🔥分析完毕，重复工作一次编写\n\n代码分析环节到这里几乎就到了柳暗花明枯木逢春的境地了。\n\n我们的主观意图很好地传递给了机器人，然后，我们让机器人根据**mongoose文档**的要求，书写后续的 `Schema`和`Model`。\n\n因为 `TS`的类型定义，比如`TSStringKeyword `， 也就是我们平时书写的 `:string`，总能找到一个对应的`mongoose SchemaType`，比如 `mongoose.Schema.Types.String`。\n\n**我们平时就是花了比较多的时间在写这种重复代码。**\n\n最后，因为本文并不是工具开发介绍，就不贴具体实现了，如果有感兴趣的，后续视情况再写一篇《实践》。\n\n送一个动图，证明我没说谎。\n\n![](https://lanhaooss.oss-cn-shenzhen.aliyuncs.com/images/329/3.gif)"
}