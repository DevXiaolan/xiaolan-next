{
  "content": "> 上一篇： [左手抽象语法树，右手自动化编程\n](https://lanhao.name/blog/329)\n\n### 前调：一些吐槽\n\n因为开发过大大大大大大量的 `Restful API` ，越来越厌烦那种一成不变的代码组织方式。\n\n以 `egg`为例，要增加一个接口，需要经历繁琐的操作\n\n```\n[路由里注册] ---> [编写 controller] ---> [编写 service] \n```\n#### 哪怕我只是想实现一个 `a+b => c`！\n\n除此以外，我还调研过某几个比较大的 **函数计算** 服务商，看看有没有什么好的途径，可以更简便地进行**简单接口开发**。\n\n让人很失望，天下技术一大抄，它们无一例外都是这样的开发模型：\n\n```\nfunction(event, context, callback) {}\n或者\nfunction(event, context) {}\n```\n于是你不得不这样写你的代码\n\n```\n// 举例\nfunction(event, context, callback) {\n  const { a, b } = event.arguments; \n  callback(a+b);\n}\n```\n\n#### 这算个什么鬼函数？！\n\n你必须改变第一直觉，严格按照厂商的要求来写你的代码，并且寄希望于**有人站出来要求它们统一`event`、`context`这些旁系知识的实现细节**。\n\n### 并且！\n\n你很难进行本地测试！\n\n你要构造奇奇怪怪的对象作为参数。哪怕只是测试**两数相加**.\n\n##### OK! 如果你说，稍微学习一下，其实还是可以用的吧。\n\n#### 可以用就是我们的追求吗？要 **应然** 还是 **实然** ？\n\n#### 难道我们期望的样子，不应该是这样吗？\n\n```\n// 🔥🔥\nfunction (a, b) {\n\treturn a+b;\n}\n```\n\n### 正文开始：\n\n所以，如果我需要实现一个 `a+b => c` 的接口，\n\n我期望我的代码是这样的：\n\n```\nexport default (a: number, b: number): number => {\n  return a + b;\n}\n```\n我期望我的测试是这样的：\n\n```\ndescribe('sum', () => {\n  it('1+1 is 2', () => {\n    assert.equal(sum(1,1), 2);\n  });\n});\n```\n#### 十分明显好吗！\n\n它并不受制于具体平台实现；\n\n它并不需要你学习其他旁系知识，只关注你的功能本身；\n\n它方便测试，因为它就是一个不能再普通的函数；\n\n它可复用！\n\n![](https://lanhaooss.oss-cn-shenzhen.aliyuncs.com/images/331/1.png)\n\n\n### 多说无益，直接动手\n\n```\nexport default (a: number, b: number): number => {\n  return a + b;\n}\n```\n\n有过上一篇的基础，我们直奔抽象语法树：\n\n```\n// 由于只有一行代码，结构就简单多了\n{\n\ttype: 'ExportDefaultDeclaration',\n\tdeclaration: {\n\t\ttype: 'ArrowFunctionExpression',\n\t\tparams: [ 下文展开 ],\n\t\tbody: { 不重要 },\n\t\treturnType: { 下文展开 }\n\t}\n}\n\n```\n\n我们还是从整体上先看一下，上面这个结构充分表达了源代码的意图：\n\n- 这是一个 `export default`声明 (`ExportDefaultDeclaration `)\n- 声明的内容是一个箭头函数 (`ArrowFunctionExpression `)\n\n考虑到，我们希望从这一行代码里面，生成**提供HTTP服务**的基础代码，\n\n那么我们的主要任务就是，从以上有限的信息当中，提取出**Restful API**需要的基础信息：\n\n- Method\n- Path\n- 请求参数\n\n#### 🤖 我们一个一个来解决：\n\n1. HTTP Method\n\n\t首选是要确定这个接口，最终通过什么 `Method`对外服务，在这里源代码并不能提供任何有效信息。\n\t\n\t**那么我们就默认用 GET 好了**\n\t\n\t> 🔥其他的 Method，会在文末提及\n2. Path， 或者叫 URL\n\n\t对于一个接口来说，这也是十分关键的信息，这里我们有两种解决方案\n\t- 使用函数名，如果有的话\n\t- 使用当前文件名\n\t\n\t**我们姑且把 URL 定为  `/sum` 好了**\n\t\n\t> 🔥 笔者的一个实验性项目里，使用的是文件名\n3. 请求参数\n\n\t如果说前面两点都是基于约定，或者一些简单的手段，\n\t\n\t那么在请求参数这个环节，我们必须上价值了，要让 `ast` 发挥作用！\n\t\n\t我们先展开一下上面 `ast` 里关于函数参数的部分：\n\n\t```\n\t// params 部分\n\t[\n\t\t{\n\t\t\tname: 'a',\n\t\t\ttypeAnnotation: { type: 'TSNumberKeyword' }\n\t\t},\n\t\t{\n\t\t\tname: 'b',\n\t\t\ttypeAnnotation: { type: 'TSNumberKeyword' }\n\t\t},\n\t]\n\t```\n\t#### 好家伙，可以拿到参数名 `a` 和 `b` 了\n\t结合 `TSNumberKeyword` 信息，我们甚至能笃定这两个参数是数字类型。\n\t\n\t#### 知道类型，就可以做参数校验！\n\t> 🔥通过原始函数定义的参数类型生成 http 参数校验逻辑，比起手工编写 `Joi` 配置要可靠得多。\n\t\n\t#### 等等，还有一个问题没解决\n\t\n\t参数名和参数类型都有了，缺的就是参数位置以及 `content-type` 。\n\t\n\t约定大法好，根据多年开发总结得出：\n\t\n\t**总所周知， GET 请求的参数就放在 queryString 里吧。**\n\t\n\t**至于 `content-type` 统一使用 `application/json` 不接受反驳**\n\t\n### 齐活了\n\n结合上面收集到的信息，我们可以想象最终的场景是：\n\t\n- step 1 : 按上面的方式，编写一个不能再普通的函数\n- step 2: 使用我们编写好的工具，运行这个函数\n- step 3: 可以通过 `http://127.0.0.1:3000/sum?a=11&b=22` 来访问这个接口，并且得到结果 33\n\n![](https://lanhaooss.oss-cn-shenzhen.aliyuncs.com/images/331/2.png)\n\n通过这个截图可知，虽然实现细节比较多，但是**可行性**是没问题的。\n\n并且笔者已经做出了一个实验性项目。\n\n如果对这种模式比较感兴趣，欢迎前来讨论，在这里就不打广告了。\n\n\n### FAQ 环节\n\n- 更多的 HTTP_METHOD 怎么办？总不能都用 GET 吧\n\n\t> 目前我选能用的方案是，如果没有声明，就用一个默认的 `GET`，\n\t\n\t> 因为要尽量选一个能覆盖 90% 情况的作为默认值。\n\t\n\t> 当我需要使用其他 Method ，我的方案是显式指定，比如 \n\t\n\t```\n\texport const method = 'POST';\n\t\n\texport default (a: number, b: number): number => {\n\t  return a + b;\n\t}\n\t```\n\t这个方案可以使信息更紧凑，同时不影响函数逻辑跑本地单元测试。\n- 上面提到的入参参数位置，什么时候在 `queryString`，什么时候在其他？\n\n\t> 遵从大多数的案例，GET 的情况下使用 `queryString`， 其他情况下在 `body`\n  \n\t> 当然还有完全自定义的方案，为避广告嫌疑就不展开了，基本原则还是不影响函数核心逻辑和单元测试。\n- 上面提到的 入参参数类型 ，有什么应用场景？\n\n\t> 有了这个信息，如果你喜欢 `Joi`， 应该能很容易生成参数校验的代码了。\n\t\n\t> 或者有自己想法的话，和我一样，自己实现一套 `validator` 也不是什么难事。\n",
  "id": 331,
  "title": "一个不能再普通的函数，如何提供http服务？",
  "keywords": [
    "AST",
    "自动化",
    "FaaS"
  ],
  "createdAt": 1611305651,
  "updatedAt": 1611305651,
  "desc": "因为开发过大量的 `Restful API` ，越来越厌烦那种一成不变的代码组织方式。有没有一种不受制于具体平台实现,不需要你学习其他旁系知识，只关注你的功能本身 的解决方案呢"
}