{
  "id": "295",
  "title": "yield方式的异步代码什么原理？（刨根向）",
  "keywords": [
    "generator",
    "yield",
    "promise"
  ],
  "content": "\n\n> \n江湖上流传着一个说法，说是通过 yield 和 generator ，就是用同步的方式写出异步的代码。\n\n真的是这样吗？\n\n也许你可以从网上搜到很多相关教程，照着样例代码，你也能写出这样的代码。但是你是否真的已经明白，这背后到底发生了什么？\n\n### 第一集，他是谁？\n这就是一个 `generator`，\n\n```javascript\nvar gen = function* (){\n\treturn 1;\n}\n```\n\n看上去像个函数，浑身有一种莫名其妙的的罪恶感，对了，他让我想起那恶心的指针。\n\n我们看看运行起来会怎么样？\n\n```javascript\ngen();\n// {}\n```\n\n看来只是长得像，跟函数没啥关系呢。\n\n我想他还有其他不为人知的地方，比如，`next()`\n\n```javascript\nvar a = gen();\nconsole.log( a.next() );\n\n// { value: 1, done: true }   duang！！\n```\n\n我明白了，要调用`next`才能让他执行起来。\n### 第二集，yield ？\n如果 `generator`遇上 `yield`会怎样？\n\n```javascript\nvar gen = function* (){\n\tyield 2;\n\treturn 1;\n}\nvar a = gen();\nconsole.log( a.next() );\n// { value: 2, done: false }\n```\n\n他并没有返回1，而是2 ，一个被 `yield`了的2 。\n\n那么这个`done`的值，应该就是告诉我还没执行完的意思吧。\n\n那我能不能多`next`几次？\n\n```javascript\nvar a = gen();\nconsole.log( a.next() );\n// { value: 2, done: false }\nconsole.log( a.next() );\n// { value: 1, done: true }\nconsole.log( a.next() );\n// { value: undefined, done: true }\n```\n\n果然，只要`done`没返回 `true`就可以一直 `next`下去。（注：`false`也可以继续`next`，不过已经没有什么意义了 ）\n\n**一个典型的迭代器呼之欲出 ！** \n\n没错，`generstor`就是一个迭代器,暂时来说和异步编程没有任何关系\n\n```javascript\nvar item = null;\nwhile( item = a.next() ){\n\tif(item.done === true){\n\t\tbreak;\n\t}\n\t// do anything with {item}\n\tconsole.log(item.value);\n}\n\n// 2 , 1\n```\n### 第三集，Promise  和 CO\n`generator`的诞生就是为了成为一个伟大的迭代器，阴差阳错之下，被用来写异步代码。\n这得从他遇上 `promise`说起。\n\n**`generator`，或者说 `yield`有一个很特别的能力——移花接木。** \n\n![](http://www.lanhao.name/img/upload/yield1.png)\n\n一个 `yield`表达式包含很丰富的操作，一行代码包含了两个阶段逻辑\n\n- 执行最右边的操作 `2+3`，把结果通过`value`带出去。（`next`的返回值）\n- 再次调用`next`时，可以接受参数，将外面的值传进来，赋值给 `a`\n\n**君子无罪，怀璧其罪** \n\n这种特异功能被眼尖的程序员发现了，一个伟大的设想诞生了。\n\n- 先将异步操作用`promise`实现，通过`yield`带出去\n- 然后执行`then`函数，获取异步处理结果\n- 再次执行`next`，将异步结果传回 `generator`内部，赋值给`yield`左边的表达式\n\n![](http://www.lanhao.name/img/upload/yield2.png)\n\n**如此一来，这一行代码看起来就像同步代码一样！** \n\n我们看看成品代码：\n\n```javascript\nvar gen = function* () {\n  let content = yield httpGet('http://www.lanhao.name');\n  return content;\n};\n\nvar myCo = (fn) =&gt; {\n  let state = null;\n  let g = fn();\n  return (function next(data){\n\t state = g.next(data);\n\t if(state.done){\n\t  return state.value;\n\t }else{\n\t  return state.value.then( val =&gt; next(val) );\n\t }\n })();\n};\n\nvar a = myCo(gen);\n\na.then(val=&gt;console.log(val));\n\n//{\"code\":200,\"data\":[],\"message\":\"\"}\n```\n\n而且我们发现，不管`generator`逻辑如何，`Co`的写法都是一样的，不会重复编码。\n\n只要通过`Co`来执行`generator`，我们就能像同步代码一样写异步操作。\n\n**以上就是 yield方式的异步代码 原理解释** \n\n（未完）\n",
  "createdAt": 1467257644,
  "modified": 1467257644,
  "desc": "江湖上流传着一个说法，说是通过 yield 和 generator ，就是用同步的方式写出异步的代码。真的是这样吗？也许你可以从网上搜到很多相关教程，照着样例代码，你也能写出这样的代码。但是你是否真的已经明白，这背后到底发生了什么？"
}