{
  "id": "307",
  "title": "gitlab-ci 坑后感与指北",
  "keywords": [
    "ci",
    "cd",
    "gitlab"
  ],
  "content": "\n\n> \n本文的目的:\n\n最主要是备忘, 其次是分享\n\n疗效:\n\n并不能让你一下子掌握CI/CD, 这只是一个比较完整的解决方案,其他基础知识,自行补充.\n\n#### 基调\n\n> \n首先,这不是屠龙刀,不要奢望一篇文章可以走遍天下.这里只是提供一个具体的落地方案, 一个具体的技术选型.\n\n#### 阶段1: 代码仓库\n关于 **代码仓库** , 本文选取的方案是 `gitlab`\n\n`gitlab`的搭建:\n\n以目前的情况来说, 推荐使用`docker`来搭建你的系统, 不然你会陷入各种膜明其妙的问题.\n\n> \ndocker的知识, 请自行补充一下,篇幅有限不能展开细说.\n\n在这里我推荐一个:\n\n`https://hub.docker.com/r/sameersbn/gitlab/`\n\n打开以后直接搜索`Quick Start`, 按照`docker-compose`的方式启动你的`gitlab`. \n\n> \n不要对英文心存恐惧 ---- 孔子\n\n下载好  `docker-compose.yml`之后不要急着启动, 需要修改几个参数:\n\n> \n需要学习一点点yml的知识, 大约5分钟, 自行google\n\n- `GITLAB_SECRETS_DB_KEY_BASE`, \n- `GITLAB_SECRETS_SECRET_KEY_BASE`, \n- `GITLAB_SECRETS_OTP_KEY_BASE`\n\n上面三个是`gitlab`用于加密时用的key, 随便给个长度64的字符串, 这块不做 深究.\n\n- `GITLAB_ROOT_EMAIL`\n- `GITLAB_ROOT_PASSWORD`\n\n上面两个就是初始化时管理员账号的`账号密码`, 按自己的需要填写\n\n- `GITLAB_HOST`\n\n这是 **gitlab** 内部使用的地址, 这关系到你gitlab页面上的项目地址,没设置的话, 到时候显示的是`127.0.0.1`, 这个鬼才能`clone`下来.\n\n> \n这个 host 一旦设置, 初始化完就改不了了, 所以一定要在第一次启动之前 就设置好.\n\n#### 启动\n`docker-compose up`\n\n一系列的初始化信息以后, 你就能访问你的gitlab了.\n\n默认是  `http://{你的IP}:10080`\n\n`其他关于gitlab的使用技巧, 就不深入了.\n能关注这篇文章的都不是萌新了,这些内容自己补充吧.\n`\n#### 阶段2: 提交触发\n接上文.\n\n`gitlab-ci`在最新版的`gitlab`已经是内置的了, 只要项目里有`.gitlab-ci.yml`,同时有对应的`gitlab-runner`, 就能实现`CI`, 相比之下不需要太多的配置.\n\n> \n名词解释:\n\n.gitlab-ci.yml:\n\n这是gitlab-ci使用的任务描述文件, 里面主要是定义CI的过程需要执行哪些行为, 简单说就是, 要进行哪几个步骤, 每个步骤是哪些命令.\n\ngitlab-runner:\n\n另一个程序, 也可以用docker启动, 就是负责执行 CI 任务的机器人, runner这块后面会展开讲.\n\n**启动并注册`gitlab-runner`** \n\n我们还是使用`docker`来启动,这是一个大方向\n\n```javascript\ndocker run -d --name gitlab-runner --restart always \\\n\n-v /srv/gitlab-runner/config:/etc/gitlab-runner \\\n\n-v /var/run/docker.sock:/var/run/docker.sock \\\n\ngitlab/gitlab-runner:latest\n```\n\n> \n想深入了解的话, 请看 \n\nhttps://docs.gitlab.com/runner/install/docker.html\n\n**敲黑板!!** \n\n在这里, 我们将宿主机的`docker.sock`映射进去,让`runner`可以跟宿主用同一个`daemon`, (意味着你进去runner内部执行`docker images`是可以看到外面的镜像列表的), 这样做是埋下一个**伏笔** , 以便后面阶段使用`dind`(docker in docker)时, 获得更好的体验.\n\n**继续** \n\n好了, 这个时候你启动了一个`runner`, 你要告诉它应该到哪里去\"服役\",\n\n这一步叫做: **注册** \n\n> \n注册runner的方式请看 \n\nhttps://docs.gitlab.com/runner/register/index.html#docker\n\n不过, 还是请你使用以下命令来注册:\n\n```javascript\ndocker exec -it gitlab-runner gitlab-runner register \\\n\n--docker-volumes /var/run/docker.sock:/var/run/docker.sock \\\n\n--docker-privileged\n```\n\n这里使用了两个参数, 都是为了 **docker in docker** 能得到更好的体验而服务的.\n\n输入以上命令后, 根据提示填写信息, 其中:\n\n- host,token 这些, 请打开你刚装好的gitlab, 进入 `Admin area`-`Runners `,然后照着填写就是了\n- 特别注意期间会让你选一个`executor `类型, 个人推荐最好的方式是`docker `, 至于`shell`这种方式, 玩玩可以,实际使用时副作用太多.\n- 更多参数的细节, 自行研究.\n\n完成以上步骤之后, 你在`gitlab`- `Admin area`-`Runners `页面就能看到注册好的`runner`了, 当然你现在还是感觉不到它的作用.\n\n```javascript\n这个环节内容比较多, 操作比较多, 走到这里建议休息一下喝杯茶.\n```\n#### 阶段3: Runner Job\n这个阶段, 是指代码提交以后, `gitlab-runner`会自动读取项目的`.gitlab-ci.yml`, 运行里面定义的每个`Job`.\n\n这里给出一个极简的`.gitlab-ci.yml`例子,\n\n它做的就是, 在提交代码以后, 自动的**测试** , 自动的**构建** , 自动的**发布** :\n\n```javascript\nstages:\n  - test\n  - build\n  - deploy\n\njob_01:\n  stage: test\n  image: dev_tool/node_builder:1.0.0\n  script: \n   - npm install --registry=https://registry.npm.taobao.org\n   - node server.js &amp;\n   - node test_api.js\n\njob_02:\n  stage: build\n  image: gitlab/dind\n  script:\n  - docker build -t ci-demo:latest .\n\njob_03:\n  stage: deploy\n  image: dev_tool/rancher-cli:latest\n  script:\n  - rancher-tool init\n  - rancher up -d  --pull --force-upgrade --confirm-upgrade\n```\n\n一目了然, 上面的第一个定义: `stages`数组,\n\n意思是这个项目的`CI/CD`过程要执行三个步骤(`stage`),\n\n分别是`test测试`-`build编译`-`deploy发布`\n\n然后下面的三个`job_*`,名字是随意的, 重点是里面的`stage`属性,\n\n告诉`gitlab-ci`这个任务是在哪个`stage`执行的,\n\n一个`stage`你可以写很多个`job`\n\n**敲黑板!!!** \n\n需要注意的是, 我们之前选择了`docker executor`, `job`里面就要声明`image`属性,指定这个`Job`的`scripts`要在哪个`image`里面运行.\n\n**重点说明!! 再次大力敲黑板!!** \n\n这里第二步使用了`gitlab/dind`, 仔细看`script`, 这是在一个容器里面去构建一个镜像, 为了**整体体验** 与**构建效率** 着想, 我们之前注册`runner`的时候,将宿主机的`docker.sock`映射进去是十分必要的!!\n(重新翻上去看吧)\n\n**看到这里, 聪明的朋友已经发现了,** \n\n我们需要自己**打造** 一批用于运行`Job`的基础镜像, 这些镜像里要预先安装好我们需要的依赖环境.\n\n举个栗子:\n\n你要在`build`这一步做`webpack`打包的话, 你要准备好一个内部安装好`webpack`的镜像(相关的`node`,`npm`之类就更不用说了)\n\n**听起来好麻烦?** \n\n也不是, 这是个 **功在当代,利在千秋** 的行为, 前期打造好基础镜像, 后面的项目就可以很容易写`CI Job`了.\n\n> \n更多 gitlab-ci.yml 的高级写法,还是建议看官方文档\nhttps://docs.gitlab.com/ee/ci/yaml/README.html\n\n#### 阶段4: 坐享其成 &amp;&amp; 总结\n如果按照上面的步骤把这个系统搭建起来以后, 你应该已经能够感受到`gitlab-ci`带来的好处了.\n\n现在你只管提交代码, 就能快速看到新功能集成到相应的环境了.\n\n此后, 你只要写好每一步的`Job`就可以了.\n\n尤其是**测试** 这个环节.\n\n尤其是**测试** 这个环节. \n\n尤其是**测试** 这个环节.\n### 后记\n- `gitlab`真的很吃资源, 虚拟机玩够呛, 团队用的话, 建议装一台PC来搭建.\n- `基础镜像`别偷懒, 多打磨,让你的`scripts`可以更简洁\n- 更进一步的话, 自己开发一系列的命令行工具, 让你的`scripts`更强大. \n- 有事找我, 包教会.\n\n",
  "createdAt": 1514636100,
  "modified": 1514642654,
  "desc": "首先,这不是屠龙刀,不要奢望一篇文章可以走遍天下.这里只是提供一个具体的落地方案, 一个具体的技术选型. 并不能让你一下子掌握CI/CD, 这只是一个比较完整的解决方案,其他基础知识,自行补充."
}