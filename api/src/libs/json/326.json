{
  "id": 326,
  "title": "一篇就够·通关Event Loop执行顺序",
  "keywords": [
    "js",
    "event loop"
  ],
  "content": "<blockquote><p>先说明，本文针对的是<code>node.js</code>运行时，由<code>uv</code>实现的<code>event loop</code>。</p><p>所有理论依据来源于 <code>node.js</code>源码。（版本略）</p></blockquote>\n\n<h3>0x00 总有面试官要刁难朕</h3>\n\n<p>我们不妨看一下这样的题目</p>\n\n<pre><code>console.log(1)\n\nsetTimeout(() =&gt; {\n  console.log(2)\n}, 0)\n\nPromise.resolve().then(() =&gt; {\n\tconsole.log(3)\n}).then(() =&gt; {\n\tconsole.log(4)\n})\n\nconsole.log(5)\n\n请问上面代码的打印结果？\n▇▇▇▇▇▇▇▇▇▇  &lt;--- 刮开查看答案</code></pre>\n\n<p>对吧，无数次被这种装X面试题恶心。</p>\n\n<blockquote><p>小声哔哔：谁项目里会这样写代码？</p></blockquote>\n\n<p><strong>不过恶心归恶心，不管有没有实用性，透过这些题目来弄清楚技术的真相，是没有坏处的。</strong></p>\n\n<p><strong>我们的目标是: 以后还有类似的题目，不管千变万化，直接通关</strong></p>\n\n<p><img alt=\"\" src=\"https://lanhaooss.oss-cn-shenzhen.aliyuncs.com/images/WechatIMG1730.jpeg\"/></p>\n\n<h3>0x01 没有银弹，还是要拿源码说话</h3>\n\n<p>为了证明不是胡说八道，先贴出关键源码</p>\n\n<pre><code>// 来自 deps/uv/src/unix/core.c\nwhile (r != 0 &amp;&amp; loop-&gt;stop_flag == 0) {\n    uv__update_time(loop); \n    uv__run_timers(loop); // ⭐️ timer\n    ran_pending = uv__run_pending(loop); // ⭐️ 上一个循环一些没来得及做完的事\n    uv__run_idle(loop); // ⭐️ 底层用，暂时不懂\n    uv__run_prepare(loop); // ⭐️ 底层用，暂时不懂\n\n\t/*\n\t* 忽略几行不重要的\n    */\n\n    uv__io_poll(loop, timeout); // ⭐️io, network or file system 等等\n    uv__run_check(loop); // ⭐️ setImmediate\n    uv__run_closing_handles(loop); // ⭐️ event on(&#39;close&#39;)\n\n    if (mode == UV_RUN_ONCE) {\n     // 这里不重要\n    }\n\n    r = uv__loop_alive(loop);\n    if (mode == UV_RUN_ONCE || mode == UV_RUN_NOWAIT)\n     // 这里不重要\n  }</code></pre>\n\n<p>然后我们开始逐个去了解</p>\n\n<ul><li><p>timer</p><p>这部分主要是检查有没有可以执行的定时器，包括但不限于<code>setTimeout</code><code>setInterval</code>。</p><p>这里的的具体实现在<code>deps/uv/src/unix/timer.c</code>，简单说就是使用一个最小堆(小顶堆), 把时间最接近的一个取出来，判断当前时间是否可以执行。</p></li><li><p>pending</p><p>这个阶段是执行 上一个循环<code>poll阶段</code>还没来得及处理的callback。</p><p>这句话，在下面介绍<code>poll阶段</code>的时候才回过头来理解。</p></li><li><p>idle + prepare </p><p>按文档说是底层预留的，暂时我还没研究清楚。请忽略。</p></li><li><p>poll</p><p><strong>关键！</strong>这个阶段处理的，就是我们比较熟悉的<code>network</code><code>fs</code>之类的异步操作回调。就是说你去请求一个远程的接口，那么回调函数会在<code>poll</code>阶段执行。</p><p>然后就是跟上面<code>pending</code>的关联。</p><p>由于<code>uv__io_poll</code>代码有点长就不贴了，有兴趣自己去看。</p><p>一般来说，我们的每一个阶段，都会处理完已经就绪的所有callback，如果<code>poll</code>阶段触发大量的 callback，就会占用很多的时间。</p><p>我们的<code>uv</code>当然是不会设计成这样的，所以，它会从<code>timer</code>里拿到最小的(未来最快到达的)一个定时器的时间，作为<code>poll</code>阶段的 <code>timeout</code>。</p><p>如果<code>timeout</code>到了，还有callback没开始执行的，对不起，请到<code>pending</code>队列里。</p><blockquote><p>可能是<code>uv</code>认为，<code>poll</code>阶段的callback，相对来说对“准时”不太敏感，所以通过这样尽量确保<code>timer</code>的执行不会误差太多。</p></blockquote></li><li><p>check</p><p>为什么叫做<code>check</code>我也不清楚。</p><p>但是这个阶段将会运行我们 <code>setImmediate</code>注册的回调。</p><p>很震惊吧，<code>setImmediate</code>完全就不是<code>timer</code>那一族的~~~~</p></li><li><p>closing_handles</p><p>执行<code>close</code>事件注册的回调，放在循环的最后一个阶段，也是合情合理。</p></li></ul>\n\n<h3>0x03 那么我们练习一下</h3>\n\n<blockquote><p>关于process.nextTick</p><p>nextTick 是个复杂的实现，需要另外开一篇来讲解。</p><p>为了方便下面的练习，我暂时先把结论放出来。</p><p>nextTick会直接追加在每一个阶段末尾，就是说，如果<code>timer</code>阶段的回调里有<code>process.nextTick</code>，通过这个来注册的回调，会在紧接着的<code>pending</code>之前就执行。</p></blockquote>\n\n<p>✏️ 题目一</p>\n\n<pre><code>setTimeout(() =&gt; {\n  console.log(&#39;A&#39;)\n}, 0)\n\nsetImmediate(() =&gt; {\n  console.log(&#39;B&#39;)\n})</code></pre>\n\n<p>答案</p>\n\n<pre><code>AB 或 BA</code></pre>\n\n<p>解释：</p>\n\n<blockquote><p>首先这里的第一个知识点，是timer的第二个参数，取值范围是 [1, 2^31 - 1]。也就是说，这个 0 会被当成 1 处理。</p><p>然后根据运行环境的差异，如果进入到当前循环前，已经过去了 1ms ,那就打印 AB。</p><p>否则，如果在 1ms 内就开始了本次循环，那<code>timer</code>还没准备后，就会在下一次循环触发，自然就打印 BA。</p></blockquote>\n\n<p>-</p>\n\n<p>✏️ 题目二</p>\n\n<pre><code>const fs = require(&#39;fs&#39;)\n\nfs.readFile(__filename, () =&gt; {\n  setTimeout(() =&gt; {\n    console.log(&#39;A&#39;)\n  }, 0)\n\n  setImmediate(() =&gt; {\n    console.log(&#39;B&#39;)\n  })\n})</code></pre>\n\n<p>答案：</p>\n\n<pre><code>BA </code></pre>\n\n<p>解释</p>\n\n<blockquote><p>知识点在于<code>fs.readFile</code>，这个是 io操作，它的整个回调会在<code>poll</code>阶段执行。\n而<code>poll</code>之后马上进入<code>check</code>，所以正好先执行了刚注册的<code>setImmediate</code>。</p><p><code>setTimeout</code>自然就要等到下一个循环的<code>timer</code>阶段。</p></blockquote>\n\n<p>-</p>\n\n<p>✏️ 题目三，这个划重点</p>\n\n<pre><code>setImmediate(() =&gt; {\n  console.log(&#39;1&#39;)\n  setImmediate(() =&gt; {\n    console.log(&#39;2&#39;)\n  })\n  process.nextTick(() =&gt; {\n    console.log(&#39;nextTick&#39;)\n  })\n})\n\nsetImmediate(() =&gt; {\n  console.log(&#39;3&#39;)\n})</code></pre>\n\n<p>答案：</p>\n\n<pre><code>1 3 nextTick 2</code></pre>\n\n<p>解释：</p>\n\n<blockquote><p>首先，最外层的两个<code>setImmediate</code>会顺序注册到同一个<code>check</code>阶段，而上面提到<code>nextTick</code>会直接追加到当前阶段末尾，所以是<code>1 3 nextTick</code>而不是<code>1 nextTick 3</code> 。</p><p>而内层的<code>setImmediate</code>会注册到下一次循环的<code>check</code>阶段，所以 <code>2</code>最后打印。</p><p>请细品。</p></blockquote>\n\n<h3>0x04 继续练习之前，讲讲 promise</h3>\n\n<p>和 <code>process.nextTick</code>类似，<code>promise</code>的回调也是在当前阶段的末尾追加。</p>\n\n<p>不过有意思的是，<code>process.nextTick</code>拥有更高的优先级。</p>\n\n<p>这个实现细节，也是需要另外一篇文章来讲解（挖坑+1）。。。。</p>\n\n<h3>0x05 继续练习吧</h3>\n\n<p>✏️ 题目四</p>\n\n<pre><code>const promise = Promise.resolve()\n\npromise.then(() =&gt; {\n  console.log(&#39;A&#39;)\n})\n\nprocess.nextTick(() =&gt; {\n  console.log(&#39;B&#39;)\n})</code></pre>\n\n<p>答案：</p>\n\n<pre><code>BA</code></pre>\n\n<p>解释</p>\n\n<blockquote><p>无需解释，先记住二者的优先级。</p></blockquote>\n\n<p>-\n✏️ 题目五</p>\n\n<pre><code>setTimeout(() =&gt; {\n  console.log(1)\n}, 0)\n\nnew Promise((resolve, reject) =&gt; {\n  console.log(2)\n  for (let i = 0; i &lt; 10000; i++) {\n    i === 9999 &amp;&amp; resolve()\n  }\n  console.log(3)\n}).then(() =&gt; {\n  console.log(4)\n})\nconsole.log(5)</code></pre>\n\n<p>答案</p>\n\n<pre><code>2 3 5 4 1</code></pre>\n\n<p>解释</p>\n\n<blockquote><p>这里有个知识点，<code>new Promise</code>的参数是同步执行的。</p><p>所以 <code>2</code><code>3</code><code>5</code>都是同步顺序输出的。</p><p>然后 <code>then</code> 在一个同步的for循环后触发，会追加到本阶段末尾，所以<code>4</code>紧接着输出。</p><p>最后是<code>setTimeout </code>，会在下一个循环的<code>timer</code>阶段执行，输出 <code>1</code></p></blockquote>\n\n<p>-</p>\n\n<p><strong>🐸 BOSS戦</strong></p>\n\n<pre><code>setImmediate(() =&gt; {\n  console.log(1)\n  setTimeout(() =&gt; {\n    console.log(2)\n  }, 100)\n  setImmediate(() =&gt; {\n    console.log(3)\n  })\n  process.nextTick(() =&gt; {\n    console.log(4)\n  })\n})\nprocess.nextTick(() =&gt; {\n  console.log(5)\n  setTimeout(() =&gt; {\n    console.log(6)\n  }, 100)\n  setImmediate(() =&gt; {\n    console.log(7)\n  })\n  process.nextTick(() =&gt; {\n    console.log(8)\n  })\n})\nconsole.log(9)</code></pre>\n\n<p>答案：</p>\n\n<pre><code>9 5 8 1 7 4 3 6 2</code></pre>\n\n<p>解释：</p>\n\n<blockquote><p>你已经是一个成熟的程序员了，试着用上面的知识自己来解释吧。</p><p>Tips 可以尝试画出来，一共经过了多少个<strong>循环</strong>， 每个循环的每个<strong>阶段</strong>执行了什么。</p></blockquote>",
  "createdAt": 1584288530,
  "desc": "我们的目标是: 以后还有类似的题目，不管千变万化，直接通关",
  "modified": 1584288530
}